#include <dirent.h>
#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#include "lib/buttons.h"
#include "lib/camera.h"
#include "lib/client.h"
#include "lib/colors.h"
#include "lib/device.h"
#include "lib/display.h"
#include "lib/fonts/fonts.h"
#include "lib/image.h"
#include "lib/log.h"

#define VIEWER_FOLDER "viewer/"
#define MAX_ENTRIES 8
#define MAX_TEXT_SIZE 400
#define MAX_FILE_NAME 100

// Colors â€” Feel free to change these to fit your preference
#define BACKGROUND_COLOR WHITE
#define FONT_COLOR BLACK
#define SELECTED_BG_COLOR BYU_BLUE
#define SELECTED_FONT_COLOR BYU_LIGHT_SAND

typedef struct {
    int sockfd;
    Config config;
} Sending;

int state = 0;

void *send_image(void *arg) {
    Sending *sargs = arg;
    int sockfd = sargs->sockfd; // Be careful of this
    Config *config = &sargs->config;

    int hw_id_length = strlen(config->hw_id);
    int total_length = hw_id_length + config->payload_size;

    uint8_t *send_the_buffer = malloc(total_length);

    memcpy(send_the_buffer, config->hw_id, hw_id_length);
    memcpy(send_the_buffer + hw_id_length, config->payload, config->payload_size);

    int total_sent = 0;
    while (total_sent < total_length) {
        int num_sent = send(sockfd, send_the_buffer + total_sent, total_length - total_sent,
                            0); // Will have to fix
        if (num_sent <= 0)
            break;
        total_sent += num_sent;
    }
    free(send_the_buffer);

    client_receive_response(sockfd);
    client_close(sockfd);
    state = 2;
    sleep(2);
    state = 3;
    free(sargs);

    return NULL;
}

void draw_status_bar(void) {
    if (state == 0 || state == 3) {
        return;
    }

    uint16_t background = BYU_BLUE;
    const char *text = "Sending...";

    if (state == 2) {
        background = GREEN;
        text = "Sent!";
    }

    int initial_y = 128 - 12;
    display_draw_rectangle(0, initial_y, 128, 128, background, true, 1);
    display_draw_string(5, initial_y + 2, text, &Font8, background, WHITE);
}

// Makes sure to deinitialize everything before program close
void intHandler(int dummy) {
    log_info("Exiting...");
    display_exit();
    exit(0);
}

/*
 * Takes in a folder, reads the contents of the folder, filtering out any files that do not end with
 * .log or .bmp. This function should check to make sure the folder exists. It fills in the entries
 * array with all of the entries in the folder, up to 8 (MAX_ENTRIES). The function returns the
 * number of entries it put into the entries array.
 */

void getFileExtension(char extension[], char fileName[]) {
    int i = 0;
    int dot = -1;

    while (fileName[i]) {
        if (fileName[i] == '.')
            dot = i;
        i++;
    }

    if (dot != -1) {
        int j = 0;
        i = dot + 1;

        while (fileName[i]) {
            extension[j++] = fileName[i++];
        }
        extension[j] = '\0';

    } else {
        extension[0] = '\0';
    }
}

int get_entries(char *folder, char entries[][MAX_FILE_NAME]) {
    // TODO: Put your code here
    DIR *dp;
    struct dirent *entry;

    int count = 0;

    dp = opendir(folder);

    if (dp == NULL) {
        log_info("aaaaaaaaa");
        return 0;
    }

    log_info("Line 81");

    while (((entry = readdir(dp)) != NULL)) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }

        char extension[10];
        getFileExtension(extension, entry->d_name);

        log_info("%s", extension);

        log_info("Hi");

        if (strcmp(extension, "bmp") == 0 || strcmp(extension, "log") == 0) {
            strcpy(entries[count], entry->d_name);
            log_info("%d", count);
            count++;

            if (count >= MAX_ENTRIES) {
                break;
            }
        }

        // entries = entries[*entry->d_name][MAX_FILE_NAME];

        // printf("%d", entries);
    }
    closedir(dp);

    log_info("debug");

    // printf("%s%d", entry->d_name);

    return count;
}

/*
 * Draws the menu of the screen. It uses the entries array to create the menu, with the num_entries
 * specifying how many entries are in the entries array. The selected parameter is the item in the
 * menu that is selected and should be highlighted. Use BACKGROUND_COLOR, FONT_COLOR,
 * SELECTED_BG_COLOR, and SELECTED_FONT_COLOR to help specify the colors of the background, font,
 * select bar color, and selected text color.
 */
// char entries[MAX_ENTRIES][MAX_FILE_NAME] = {"Clear", "Hello", "Chars", "Stars", "Flag"};
void draw_menu(char entries[][MAX_FILE_NAME], int num_entries, int selected) {
    // TODO: Put your code here
    display_clear(BACKGROUND_COLOR);

    for (int i = 0; i < num_entries; i++) {

        int y_position = 10 + (i * 16);

        if (i == selected) {
            display_draw_rectangle(0, y_position - 4, 128, y_position + 12, BYU_BLUE, true, 1);
            display_draw_string(10, y_position, entries[i], &Font8, BYU_BLUE, WHITE);

        } else {
            display_draw_string(10, y_position, entries[i], &Font8, WHITE, BLACK);
        }
    }
}

/*
 * Displays an image or a log file. This function detects the type of file that should be draw. If
 * it is a bmp file, then it calls display_draw_image. If it is a log file, it opens the file, reads
 * 100 characters (MAX_TEXT_SIZE), and displays the text using display_draw_string. Combine folder
 * and file_name to get the complete file path.
 */
void draw_file(char *folder, char *file_name) {
    // TODO: Put your code here

    char path[200];

    snprintf(path, sizeof(path), "%s%s", folder, file_name);

    char extension[10];
    getFileExtension(extension, file_name);

    display_clear(BACKGROUND_COLOR);

    if (strcmp(extension, "bmp") == 0) {
        display_draw_image(path);
    } else if (strcmp(extension, "log") == 0) {
        FILE *fp = fopen(path, "r");

        if (fp == NULL) {
            log_info("Could not open file in directory");
        }

        char buffer[MAX_TEXT_SIZE + 1];

        size_t read = fread(buffer, 1, MAX_TEXT_SIZE, fp);

        buffer[read] = '\0';

        display_draw_string(5, 10, buffer, &Font8, BACKGROUND_COLOR, FONT_COLOR);
        fclose(fp);
    }

    delay_ms(2000);

    /* FILE *fp;
    char buffer[100];

    fp = fopen("file", "r");

    call file_extension function

    if (file_extension == 'bmp') {
        display_draw_image()
    } else if (file_extension == 'log') {
        while (fgets(buffer, sizeof(buffer), fp) != NULL) {
            buffer[strcspn(buffer, "\n")] = '\0';

            store it in a variable so I can then execute it from main will display the characters
    from the log file on the display

        }
    }

    fclose(fp);
     */
}

void send_flick(Config *config) {
    config->port = "2240";
    config->host = "ecen224.byu.edu";
    config->hw_id = "8C1D6E9B3";
    log_info("%s\n", config->host);

    int sockfd = client_connect(config);
    Sending *args = malloc(sizeof(Sending));
    args->sockfd = sockfd;
    args->config = *config;
    state = 1;

    pthread_t t;
    pthread_create(&t, NULL, send_image, args);
    pthread_detach(t);

    log_info("You have made it [.]_[.]");
}

/* void send_flick(Config *config) {
    config->port = "2240";
    config->host = "ecen224.byu.edu";
    config->hw_id = "8C1D6E9B3";
    log_info("%s\n", config->host);

    int sockfd = client_connect(config);

    client_send_image(sockfd, config);
    client_receive_response(sockfd);
    client_close(sockfd);

    log_info("You have made it [.]_[.]");
} */

void camera_helper_func(Config *config) {
    uint8_t *my_new_buf = malloc(sizeof(uint8_t) * 49206);
    camera_capture_data(my_new_buf, 49206);
    camera_save_to_file(my_new_buf, 49206, "doorbell.bmp");
    Bitmap *map = malloc(sizeof(uint8_t) * 49206);
    create_bmp(map, my_new_buf);
    // This struct is for the send_flick helper function
    config->payload = my_new_buf;
    config->payload_size = 49206;
    display_draw_image_data(map->pxl_data, 128, 128);
    while (true) {
        if (button_up() == 0) {
            reset_pixel_data(map);
            remove_color_channel(GREEN_CHANNEL, map);
            display_draw_image_data(map->pxl_data, 128, 128);

            while (button_up() == 0) {
                delay_ms(1);
            }
        }

        if (button_left() == 0) {
            reset_pixel_data(map);
            remove_color_channel(BLUE_CHANNEL, map);
            display_draw_image_data(map->pxl_data, 128, 128);

            while (button_left() == 0) {
                delay_ms(1);
            }
        }

        if (button_right() == 0) {
            reset_pixel_data(map);
            remove_color_channel(RED_CHANNEL, map);
            display_draw_image_data(map->pxl_data, 128, 128);

            while (button_right() == 0) {
                delay_ms(1);
            }
        }

        if (button_down() == 0) {
            reset_pixel_data(map);
            or_filter(map);
            display_draw_image_data(map->pxl_data, 128, 128);

            while (button_down() == 0) {
                delay_ms(1);
            }
        }

        if (button_center() == 0) {
            send_flick(config);
            display_clear(BACKGROUND_COLOR);
            destroy_bmp(map);
            free(map);
            free(my_new_buf);

            while (button_center() == 0) {
                delay_ms(1);
            }

            break;
        }
    }
}

int main(void) {

    signal(SIGINT, intHandler);
    display_init();
    buttons_init();

    // This struct is for send_flick and camera_data
    Config config;

    display_clear(BACKGROUND_COLOR);

    log_info("Starting...");

    char entries[MAX_ENTRIES][MAX_FILE_NAME];

    int num_entries = get_entries(VIEWER_FOLDER, entries);

    log_info("aaaaa");

    int selected = 0;

    draw_menu(entries, num_entries, selected);

    log_info("after");

    while (true) {
        delay_ms(200);

        draw_status_bar();

        // Example of how to interact with a button
        if (button_up() == 0) {
            // Do something upon detecting button press
            selected--;
            if (selected < 0) {
                selected = num_entries - 1;
            }

            draw_menu(entries, num_entries, selected);

            while (button_up() == 0) {
                // Delay while the button is pressed to avoid repeated actions
                delay_ms(1);
            }
        }

        if (button_down() == 0) {
            // Do something upon detecting button press
            selected++;
            if (selected >= num_entries) {
                selected = 0;
            }

            draw_menu(entries, num_entries, selected);

            while (button_down() == 0) {
                // Delay while the button is pressed to avoid repeated actions
                delay_ms(1);
            }
        }

        if (button_right() == 0) {
            // Do something upon detecting button press
            draw_file(VIEWER_FOLDER, entries[selected]);
            // Use display_draw_image_data to show newly taken photo
            draw_menu(entries, num_entries, selected);

            while (button_down() == 0) {
                // Delay while the button is pressed to avoid repeated actions
                delay_ms(1);
            }
        }

        if (button_center() == 0) {
            // Do something upon detecting button press
            display_clear(BACKGROUND_COLOR);
            display_draw_string(23, 60, "Say Cheese!", &Font12, WHITE, BYU_PLUM);
            delay_ms(2000);
            camera_helper_func(&config);
            char entries[MAX_ENTRIES][MAX_FILE_NAME];
            num_entries = get_entries(VIEWER_FOLDER, entries);

            // name it doorbell.bmp
            // update contents of the menu to include newly saved file

            draw_menu(entries, num_entries, selected);
            draw_status_bar();

            while (button_center() == 0) {
                // Delay while the button is pressed to avoid repeated actions
                delay_ms(1);
            }
        }
    }

    log_info("Huh");
    return 0;

    // draw_menu(entries, 5, selected % 5);

    // Use this to fill in with entries from the directory
    // char entries[MAX_ENTRIES][MAX_FILE_NAME];

    // TODO: Initialize the hardware

    // TODO: Get directory contents using get_entries function

    // TODO: Draw menu using draw_menu function
}
